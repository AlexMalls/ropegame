<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Sala 3D – Giroscópio</title>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <style>
    html, body { height:100%; margin:0; background:#000; overflow:hidden; }
    #hud {
      position: fixed; inset: 0 0 auto 0; display:flex; gap:.5rem; padding:.5rem;
      justify-content:center; pointer-events:none;
    }
    #btnPermissao, #btnDebug, #btnRecalibrar {
      pointer-events:auto; font:600 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto;
      padding:.6rem .9rem; border-radius:999px; border:none; background:#fff; cursor:pointer;
    }
    #btnDebug { background:#eee; }
    #btnRecalibrar { background:#cfc; }
    #debug {
      position: fixed; bottom:.5rem; left:.5rem; color:#fff; font:12px/1.3 ui-monospace, Menlo, Consolas, monospace;
      background:rgba(0,0,0,.45); padding:.5rem .6rem; border-radius:.5rem; display:none; white-space:pre;
    }
  </style>
</head>
<body>
  <div id="hud">
    <button id="btnPermissao">Ativar giroscópio</button>
    <button id="btnRecalibrar">Recalibrar</button>
    <button id="btnDebug" aria-pressed="false">Debug</button>
  </div>
  <div id="debug"></div>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from "three";
    import { DeviceOrientationControls } from "/jsm/controls/DeviceOrientationControls.js";

    // --- Render básico ---
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(90, 2, 0.01, 100); // FOV maior
    camera.position.set(0, 0, 0);
    scene.add(camera);

    // --- Sala cúbica maior e textos menores ---
    function faceTexture(label, bg='#444', fg='#fff') {
      const size = 1024;
      const cnv = document.createElement('canvas');
      cnv.width = cnv.height = size;
      const ctx = cnv.getContext('2d');
      ctx.fillStyle = bg; ctx.fillRect(0,0,size,size);
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let i=0;i<=16;i++){
        const p = Math.round((i/16)*size);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,size); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(size,p); ctx.stroke();
      }
      ctx.fillStyle = fg;
      ctx.font = "bold 100px system-ui, -apple-system, Segoe UI, Roboto"; // menor
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,.35)"; ctx.shadowBlur = 16;
      ctx.fillText(label, size/2, size/2);
      return new THREE.CanvasTexture(cnv);
    }

    const materials = [
      new THREE.MeshBasicMaterial({ map: faceTexture("DIREITA",  "#2a4b8d"), side: THREE.BackSide }), // +X
      new THREE.MeshBasicMaterial({ map: faceTexture("ESQUERDA", "#8d2a2a"), side: THREE.BackSide }), // -X
      new THREE.MeshBasicMaterial({ map: faceTexture("CIMA",     "#2a8d4b"), side: THREE.BackSide }), // +Y
      new THREE.MeshBasicMaterial({ map: faceTexture("BAIXO",    "#8d7b2a"), side: THREE.BackSide }), // -Y
      new THREE.MeshBasicMaterial({ map: faceTexture("FRENTE",   "#5b2a8d"), side: THREE.BackSide }), // +Z
      new THREE.MeshBasicMaterial({ map: faceTexture("TRÁS",     "#2a8a8d"), side: THREE.BackSide })  // -Z
    ];

    const room = new THREE.Mesh(new THREE.BoxGeometry(20,20,20), materials);
    scene.add(room);

    // --- Controles de giroscópio (rotacionam a CÂMERA) ---
    const controls = new DeviceOrientationControls(camera);
    controls.enabled = false;

    // Offset de recalibração
    let calibrationOffset = new THREE.Quaternion();

    // iOS exige permissão via gesto do usuário
    const btnPermissao = document.getElementById('btnPermissao');
    btnPermissao.addEventListener('click', async () => {
      try {
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
          const resp = await DeviceOrientationEvent.requestPermission();
          if (resp !== 'granted') throw new Error('Permissão negada');
        }
        controls.enabled = true;
        btnPermissao.textContent = "Giroscópio ativo";
        btnPermissao.disabled = true;
      } catch (err) {
        alert("Não foi possível ativar o giroscópio: " + err.message);
      }
    });

    // Botão Recalibrar
    document.getElementById('btnRecalibrar').addEventListener('click', () => {
      calibrationOffset.copy(camera.quaternion).invert();
    });

    // --- Debug opcional ---
    const debugDiv = document.getElementById('debug');
    const btnDebug = document.getElementById('btnDebug');
    btnDebug.addEventListener('click', () => {
      const on = debugDiv.style.display !== 'block';
      debugDiv.style.display = on ? 'block' : 'none';
      btnDebug.setAttribute('aria-pressed', String(on));
    });

    function eulerFromCamera(cam){
      const e = new THREE.Euler().setFromQuaternion(cam.quaternion, 'YXZ');
      const toDeg = r => THREE.MathUtils.radToDeg(r);
      const norm = v => ((v+180)%360+360)%360-180;
      return { yaw: norm(toDeg(e.y)), pitch: norm(toDeg(e.x)), roll: norm(toDeg(e.z)) };
    }

    // --- Resize ---
    function resizeRendererToDisplaySize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      const needResize = renderer.domElement.width !== width || renderer.domElement.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
    }
    window.addEventListener('resize', resizeRendererToDisplaySize);
    resizeRendererToDisplaySize();

    // --- Loop ---
    renderer.setAnimationLoop(() => {
      resizeRendererToDisplaySize();
      if (controls.enabled) controls.update();

      // aplica recalibração
      camera.quaternion.premultiply(calibrationOffset);

      if (debugDiv.style.display === 'block') {
        const { yaw, pitch, roll } = eulerFromCamera(camera);
        debugDiv.textContent =
`Yaw (Y esq/dir): ${yaw.toFixed(1)}°
Pitch (X cima/baixo): ${pitch.toFixed(1)}°
Roll (Z rolagem): ${roll.toFixed(1)}°`;
      }
      renderer.render(scene, camera);
    });

    // Suporte mouse p/ teste em desktop
    (function enableMouseLook(){
      let dragging=false, sx=0, sy=0, yaw=0, pitch=0;
      const tmp = new THREE.Euler(0,0,0,'YXZ');
      window.addEventListener('pointerdown', e => { if(controls.enabled) return; dragging=true; sx=e.clientX; sy=e.clientY; });
      window.addEventListener('pointerup',   () => dragging=false);
      window.addEventListener('pointermove', e => {
        if (!dragging || controls.enabled) return;
        const dx = (e.clientX - sx) * 0.003;
        const dy = (e.clientY - sy) * 0.003;
        sx = e.clientX; sy = e.clientY;
        yaw   += dx;
        pitch += dy;
        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        tmp.set(pitch, yaw, 0);
        camera.quaternion.setFromEuler(tmp);
      });
    })();
  </script>
</body>
</html>
