<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <title>FPS 3D — Menu + HUD (Mobile Gyro Auto)</title>
  <style>
    :root{ --navy:#0b2a6b; --navy2:#001021; --fg:#e6ebf5; }
    html,body{ height:100%; margin:0; background:#000; color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body{ height:100dvh; }
    canvas{ width:100vw; height:100dvh; display:block; touch-action:none; }

    /* ===== Overlay de Menu ===== */
    #menu{ position:fixed; inset:0; display:grid; place-items:center; z-index:3;
      background:
        linear-gradient(180deg, rgba(0,16,33,.66), rgba(0,0,0,.68)),
        radial-gradient(700px 500px at 50% 18%, rgba(11,42,107,.22), rgba(0,0,0,0) 60%);
      -webkit-backdrop-filter: blur(4px) saturate(1.05);
      backdrop-filter: blur(4px) saturate(1.05);
      transition: opacity .45s ease, visibility .45s ease; }
    #menu.hide{ opacity:0; visibility:hidden; }

    .panel{ padding:28px 28px 22px; border-radius:18px; width:min(92vw, 520px);
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.22));
      border:1px solid rgba(255,255,255,.06); box-shadow: 0 20px 60px rgba(0,0,0,.55);
      text-align:center; }
    .panel h1{ margin:0 0 .5rem; font-size: clamp(26px, 5vw, 40px); letter-spacing:.4px; }
    .panel p{ margin:.25rem 0 1.25rem; opacity:.8; font-size: clamp(14px, 2.2vw, 16px); }

    .btn{ appearance:none; border:none; cursor:pointer; padding:14px 28px; font-weight:800; font-size:16px; border-radius:14px;
      background: linear-gradient(135deg, var(--navy2) 0%, var(--navy) 100%);
      color:var(--fg); box-shadow: 0 12px 34px rgba(11,42,107,.40), inset 0 1px 0 rgba(255,255,255,.07);
      transition: transform .15s ease, box-shadow .2s ease, filter .2s ease; }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 16px 42px rgba(11,42,107,.55), inset 0 1px 0 rgba(255,255,255,.09); }
    .btn:active{ transform: translateY(0); filter: brightness(.96); }

    .btn.small{ padding:10px 14px; font-weight:700; font-size:14px; border-radius:12px; }
    .btn.ghost{ background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); box-shadow:none; border:1px solid rgba(255,255,255,.08); }

    /* ===== HUD Responsiva ===== */
    .hud{ position:fixed; inset:0; z-index:2; pointer-events:none;
      padding: calc(env(safe-area-inset-top,0px) + 8px) calc(env(safe-area-inset-right,0px) + 12px) calc(env(safe-area-inset-bottom,0px) + 8px) calc(env(safe-area-inset-left,0px) + 12px);
      display:flex; flex-direction:column; justify-content:space-between; }
    .hud .row{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .hud .left,.hud .right{ display:flex; align-items:center; gap:10px; }
    .hud .badge{ pointer-events:none; opacity:.75; font-weight:700; font-size:12px; padding:6px 8px; border-radius:10px;
      background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.08); }
    .hud .controls button{ pointer-events:auto; }

    @media (orientation: landscape){
      .hud{ padding-left: calc(env(safe-area-inset-left,0px) + 18px); padding-right: calc(env(safe-area-inset-right,0px) + 18px); }
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- MENU -->
  <div id="menu" aria-modal="true" role="dialog">
    <div class="panel" aria-label="Menu inicial">
      <h1>FPS 3D • Protótipo</h1>
      <p>Pronto para mobile e desktop. Em celulares, o <b>giroscópio</b> liga automaticamente.</p>
      <button id="play" class="btn" aria-label="Jogar">Jogar</button>
      <div class="footer" style="margin-top:12px; font-size:12px; opacity:.55;">Dica: use o botão Calibrar na HUD para alinhar o olhar.</div>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud" id="hud" aria-hidden="true">
    <div class="row top">
      <div class="left"><span class="badge">FPS 3D</span></div>
      <div class="right controls">
        <button id="calBtn" class="btn small ghost">Calibrar</button>
      </div>
    </div>
    <div class="row bottom">
      <div class="left"></div>
      <div class="right"><span class="badge" id="orientBadge">—</span></div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const menu   = document.getElementById('menu');
    const play   = document.getElementById('play');
    const hud    = document.getElementById('hud');
    const calBtn = document.getElementById('calBtn');
    const orientBadge = document.getElementById('orientBadge');

    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 1 && screen.width < 1025);

    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0,0,0,1);

    // ===== Cena base =====
    let camera = new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(0, 1.2, 38), scene);
    camera.attachControl(canvas, true);
    camera.speed = 0; // sem WASD
    camera.keysUp = camera.keysDown = camera.keysLeft = camera.keysRight = [];

    const light = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0,1,0), scene);
    light.intensity = 0.9;

    const room = BABYLON.MeshBuilder.CreateBox('room', { size: 80, sideOrientation: BABYLON.Mesh.BACKSIDE }, scene);
    const roomMat = new BABYLON.StandardMaterial('roomMat', scene);
    roomMat.diffuseColor = new BABYLON.Color3(0.06, 0.07, 0.10);
    roomMat.specularColor = new BABYLON.Color3(0, 0, 0);
    room.material = roomMat;

    const cube = BABYLON.MeshBuilder.CreateBox('cube', { size: 1 }, scene);
    cube.position = new BABYLON.Vector3(0, 0.5, -30);
    const crateMat = new BABYLON.StandardMaterial('crateMat', scene);
    crateMat.diffuseTexture = new BABYLON.Texture('https://playground.babylonjs.com/textures/crate.png', scene);
    crateMat.specularColor = new BABYLON.Color3(0.1,0.1,0.1);
    cube.material = crateMat;

    // ===== Render loop
    engine.runRenderLoop(() => scene.render());
    window.addEventListener('resize', () => engine.resize());

    // ===== HUD: orientação
    function refreshOrientationBadge(){
      const isLandscape = window.matchMedia('(orientation: landscape)').matches;
      orientBadge.textContent = isLandscape ? 'Landscape' : 'Portrait';
    }
    refreshOrientationBadge();
    window.matchMedia('(orientation: landscape)').addEventListener?.('change', refreshOrientationBadge);

    // ===== Giroscópio: auto no mobile
    let yawOffset = -Math.PI / 2, pitchOffset = 0, rollOffset = 0; // offsets de calibração (em radianos) — inicia com yaw = -90° (direita)

    async function requestMotionPermission(){
      try{
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
          const r = await DeviceMotionEvent.requestPermission();
          if (r !== 'granted') return false;
        }
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
          const r2 = await DeviceOrientationEvent.requestPermission();
          if (r2 !== 'granted') return false;
        }
      }catch(_){ /* ignore */ }
      return true;
    }

    function swapToDeviceOrientationCamera(){
      const pos = camera.position.clone();
      const fov = camera.fov; const minZ = camera.minZ; const maxZ = camera.maxZ;
      const newCam = new BABYLON.DeviceOrientationCamera('devcam', pos, scene);
      newCam.fov = fov; newCam.minZ = minZ; newCam.maxZ = maxZ;
      newCam.attachControl(canvas, true);
      // Habilitar também toque enquanto usa orientação do dispositivo
      newCam._disablePointerInputWhenUsingDeviceOrientation = false;
      scene.activeCamera = newCam;
      camera.detachControl(canvas);
      camera.dispose();
      camera = newCam;

      // Aplicar offsets de calibração sem mover posição — após os inputs do dispositivo
      camera.onAfterCheckInputsObservable.add(() => {
        const q = camera.rotationQuaternion; if (!q) return;
        const adjust = BABYLON.Quaternion.FromEulerAngles(pitchOffset, yawOffset, rollOffset);
        const finalQ = adjust.multiply(q);
        camera.rotationQuaternion.copyFrom(finalQ);
      });
    }

    async function enableGyroAuto(){
      const ok = await requestMotionPermission();
      if (!ok) return;
      swapToDeviceOrientationCamera();
    }

    function calibrate(){
      // Zera yaw/pitch atuais sem alterar a posição — evita "teleporte".
      if (!camera.rotationQuaternion) return;
      const e = camera.rotationQuaternion.toEulerAngles();
      // Tornar a orientação atual o novo "zero":
      yawOffset   = -e.y;  // compensa heading
      pitchOffset = -e.x;  // compensa inclinação
      rollOffset  = 0;     // evita rolagem lateral
    }

    // ===== Menu → iniciar =====
    play.addEventListener('click', async () => {
      menu.classList.add('hide');
      hud.setAttribute('aria-hidden','false');
      if (isMobile) {
        await enableGyroAuto();
      } else {
        canvas.requestPointerLock?.();
      }
      setTimeout(() => engine.resize(), 0);
    }, { passive:true });

    // ===== HUD: Calibrar =====
    calBtn.addEventListener('click', calibrate);
  })();
  </script>
</body>
</html>
