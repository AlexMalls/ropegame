<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <title>FPS 3D — Protótipo (Menu + HUD + Gyro + Corda + Balance + VR)</title>
  <style>
    :root{ --navy:#0b2a6b; --navy2:#001021; --fg:#e6ebf5; }
    html,body{ height:100%; margin:0; background:#000; color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body{ height:100dvh; }
    canvas{ width:100vw; height:100dvh; display:block; touch-action:none; }

    /* ===== Overlay base ===== */
    #menu, #gameover{
      position:fixed; inset:0; display:grid; place-items:center; z-index:3;
      background:
        linear-gradient(180deg, rgba(0,16,33,.66), rgba(0,0,0,.68)),
        radial-gradient(700px 500px at 50% 18%, rgba(11,42,107,.22), rgba(0,0,0,0) 60%);
      -webkit-backdrop-filter: blur(4px) saturate(1.05);
      backdrop-filter: blur(4px) saturate(1.05);
      transition: opacity .6s ease, visibility .6s ease;
    }
    #menu.hide, #gameover.hide{ opacity:0; visibility:hidden; }

    .panel{ padding:28px 28px 22px; border-radius:18px; width:min(92vw, 520px);
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.22));
      border:1px solid rgba(255,255,255,.06); box-shadow: 0 20px 60px rgba(0,0,0,.55);
      text-align:center; }
    .panel h1{ margin:0 0 .5rem; font-size: clamp(26px, 5vw, 40px); letter-spacing:.4px; }
    .panel p{ margin:.25rem 0 1.25rem; opacity:.8; font-size: clamp(14px, 2.2vw, 16px); }
    .panel .actions{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }

    .btn{ appearance:none; border:none; cursor:pointer; padding:14px 28px; font-weight:800; font-size:16px; border-radius:14px;
      background: linear-gradient(135deg, var(--navy2) 0%, var(--navy) 100%);
      color:var(--fg); box-shadow: 0 12px 34px rgba(11,42,107,.40), inset 0 1px 0 rgba(255,255,255,.07);
      transition: transform .15s ease, box-shadow .2s ease, filter .2s ease; }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 16px 42px rgba(11,42,107,.55), inset 0 1px 0 rgba(255,255,255,.09); }
    .btn:active{ transform: translateY(0); filter: brightness(.96); }

    /* ===== HUD ===== */
    .hud{ position:fixed; inset:0; z-index:2; pointer-events:none;
      padding: calc(env(safe-area-inset-top,0px) + 8px) calc(env(safe-area-inset-right,0px) + 12px) calc(env(safe-area-inset-bottom,0px) + 8px) calc(env(safe-area-inset-left,0px) + 12px);
      display:flex; flex-direction:column; justify-content:space-between; }
    .hud .row{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .hud .left,.hud .right{ display:flex; align-items:center; gap:10px; }
    .hud .badge{ pointer-events:none; opacity:.75; font-weight:700; font-size:12px; padding:6px 8px; border-radius:10px;
      background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.08); }
    @media (orientation: landscape){
      .hud{ padding-left: calc(env(safe-area-inset-left,0px) + 18px); padding-right: calc(env(safe-area-inset-right,0px) + 18px); }
    }

    /* ===== Game Over ===== */
    #gameover{
      z-index:4;
      background:
        linear-gradient(180deg, rgba(0,0,0,.88), rgba(0,0,0,.92)),
        radial-gradient(700px 500px at 50% 18%, rgba(11,42,107,.22), rgba(0,0,0,0) 60%);
    }

    /* ===== Régua de Equilíbrio ===== */
    .meter { width:120px; height:10px; border-radius:12px; background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08); position:relative; overflow:hidden; box-shadow: inset 0 1px 2px rgba(0,0,0,.5); }
    .meter .track { width:100%; height:100%; position:relative; }
    .meter .centerMark { position:absolute; top:50%; left:50%; width:2px; height:70%; background:var(--navy);
      transform:translate(-50%, -50%); border-radius:2px; opacity:.85; }
    .meter .needle { position:absolute; top:50%; left:50%; width:8px; height:70%; background:var(--fg);
      border-radius:3px; transform:translate(-50%, -50%); transition:left 0.05s linear; }
  </style>

  <!-- Babylon Core -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <!-- Materials Library (LavaMaterial) -->
  <script src="https://cdn.jsdelivr.net/npm/babylonjs-materials/babylon.lavaMaterial.min.js"></script>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- MENU -->
  <div id="menu" aria-modal="true" role="dialog">
    <div class="panel" aria-label="Menu inicial">
      <h1>FPS 3D • Protótipo</h1>
      <p>Pronto para mobile e desktop. Em celulares, o <b>giroscópio</b> liga automaticamente.</p>
      <div class="actions">
        <button id="play" class="btn" aria-label="Jogar">Jogar</button>
        <button id="freecam" class="btn" aria-label="Modo Free Cam">Free Cam</button>
        <button id="vr" class="btn" aria-label="Ativar Modo VR">VR</button>
      </div>
    </div>
  </div>

  <!-- GAME OVER -->
  <div id="gameover" aria-modal="true" role="dialog" class="hide">
    <div class="panel" aria-label="Tela de Game Over">
      <h1>Game Over</h1>
      <p>Você perdeu o equilíbrio.</p>
      <button id="restart" class="btn" aria-label="Reiniciar">Reiniciar</button>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud" id="hud" aria-hidden="true">
    <div class="row top">
      <div class="left"><span class="badge">FPS 3D</span></div>
      <div class="right controls">
        <div id="balanceMeter" class="meter">
          <div class="track">
            <div class="centerMark"></div>
            <div class="needle"></div>
          </div>
        </div>
        <span class="badge" id="speedBadge">Vel: —</span>
      </div>
    </div>
    <div class="row bottom">
      <div class="left"></div>
      <div class="right"><span class="badge" id="orientBadge">—</span></div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const menu   = document.getElementById('menu');
    const play   = document.getElementById('play');
    const freeBtn= document.getElementById('freecam');
    const vrBtn  = document.getElementById('vr');
    const hud    = document.getElementById('hud');
    const orientBadge = document.getElementById('orientBadge');
    const gameover = document.getElementById('gameover');
    const restart  = document.getElementById('restart');
    const needle = document.querySelector('#balanceMeter .needle');
    const meter  = document.getElementById('balanceMeter');
    const speedBadge = document.getElementById('speedBadge');

    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 1 && screen.width < 1025);

    let LAVA_Y = null;

    const engine = new BABYLON.Engine(canvas, true, { stencil:false });
    engine.setHardwareScalingLevel(isMobile ? 1.25 : 1.0);

    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0,0,0,1);
    scene.setRenderingAutoClearDepthStencil(1, false);
    scene.setRenderingAutoClearDepthStencil(2, false);
    scene.setRenderingAutoClearDepthStencil(3, false);
    scene.skipPointerMovePicking = true;

    // Fog global
    scene.fogMode  = BABYLON.Scene.FOGMODE_LINEAR;
    scene.fogColor = new BABYLON.Color3(0.0, 0.0, 0.0);
    scene.fogStart = 16;
    scene.fogEnd   = 120;

    // Vinheta
    scene.imageProcessingConfiguration.vignetteEnabled = true;
    scene.imageProcessingConfiguration.vignetteColor   = new BABYLON.Color4(0,0,0,1);
    scene.imageProcessingConfiguration.vignetteWeight  = 1.2;
    scene.imageProcessingConfiguration.vignetteStretch = 0.0;

    // Câmera base
    let camera = new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(0, 1.2, 38), scene);
    camera.attachControl(canvas, true);
    camera.speed = 0;
    camera.keysUp = camera.keysDown = camera.keysLeft = camera.keysRight = [];
    camera.minZ = 0.1;
    camera.maxZ = 1000;

    // Corpo do jogador
    const rig = new BABYLON.TransformNode('playerRig', scene);
    rig.position.copyFrom(camera.position);
    camera.parent = rig;
    camera.position.set(0,0,0);

    const PIVOT_DOWN = 0.6;
    rig.setPivotPoint(new BABYLON.Vector3(0, -PIVOT_DOWN, 0));

    const light = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0,1,0), scene);
    light.diffuse = new BABYLON.Color3(1.0, 0.75, 0.35);
    light.specular = new BABYLON.Color3(1.0, 0.6, 0.2);
    light.groundColor = new BABYLON.Color3(0.4, 0.25, 0.1);
    light.intensity = 0.9;

    const cube = BABYLON.MeshBuilder.CreateBox('cube', { size: 1 }, scene);
    cube.position = new BABYLON.Vector3(0, 0.5, -30);
    const crateMat = new BABYLON.StandardMaterial('crateMat', scene);
    crateMat.diffuseTexture = new BABYLON.Texture('https://playground.babylonjs.com/textures/crate.png', scene);
    crateMat.specularColor = new BABYLON.Color3(0.1,0.1,0.1);
    cube.material = crateMat;
    cube.isPickable = false;
    cube.freezeWorldMatrix();

    // Viga
    const beamY = -0.7;
    const endOffsetY = -0.7;
    const beamStart = new BABYLON.Vector3(rig.position.x, beamY, rig.position.z);
    const beamEnd   = new BABYLON.Vector3(cube.position.x, beamY + endOffsetY, cube.position.z);
    const beamDir   = beamEnd.subtract(beamStart);
    const beamLen   = beamDir.length();
    const beamMid   = beamStart.add(beamEnd).scale(0.5);

    const beam = BABYLON.MeshBuilder.CreateBox('beam', { width:0.15, height:0.08, depth:beamLen }, scene);
    beam.position = beamMid;
    beam.lookAt(beamEnd);

    const metalMat = new BABYLON.StandardMaterial('metalMat', scene);
    metalMat.diffuseTexture = new BABYLON.Texture('https://playground.babylonjs.com/textures/reflectivity.png', scene);
    metalMat.diffuseColor = new BABYLON.Color3(0.25, 0.28, 0.32);
    metalMat.specularColor = new BABYLON.Color3(0.08, 0.08, 0.10);
    metalMat.specularPower = 32;
    if (metalMat.diffuseTexture){
      metalMat.diffuseTexture.level = 0.75;
      metalMat.diffuseTexture.uScale = Math.max(1, beamLen / 4);
      metalMat.diffuseTexture.vScale = 1;
    }
    beam.material = metalMat;
    beam.renderingGroupId = 0;
    beam.isPickable = false;
    beam.freezeWorldMatrix();

    // ======== NÉVOA / LAVA / PARTÍCULAS ========
    (function makeLayeredGroundFog(){
      const roomWidth  = 350;
      const roomDepth  = 105;
      const margin     = 6;

      const planeWidth  = roomWidth  - margin*2;
      const planeHeight = roomDepth  - margin*2;

      const floorY   = -40;

      const height = 5;
      const slices = 12;
      const baseAlpha = 0.10;
      const tint = new BABYLON.Color3(1.0, 0.36, 0.10);

      const fogSlices = [];
      for (let i=0;i<slices;i++){
        const t = i/(slices-1);
        const y = floorY + 12 + t*height;

        const p = BABYLON.MeshBuilder.CreatePlane(`fogSlice${i}`, { width: planeWidth, height: planeHeight }, scene);
        p.position = new BABYLON.Vector3(0, y, 0);
        p.rotation.x = Math.PI/2;

        const m = new BABYLON.StandardMaterial(`fogMat${i}`, scene);
        m.disableLighting = true;
        m.backFaceCulling = false;

        m.opacityTexture = new BABYLON.Texture("https://playground.babylonjs.com/textures/cloud.png", scene);
        m.opacityTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
        m.opacityTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;

        const scale = 2.2 + t*1.4 + Math.random()*0.4;
        m.opacityTexture.uScale = scale;
        m.opacityTexture.vScale = scale * (0.92 + Math.random()*0.16);

        m.emissiveColor = tint.scale(0.45 + (1.5 - t)*0.35);
        m.alpha = baseAlpha * (2.0 - Math.pow(t, 1.35));
        m.alphaMode = BABYLON.Engine.ALPHA_COMBINE;

        m.fogEnabled = true;
        p.applyFog   = true;

        p.material = m;

        m.disableDepthWrite = true;
        p.renderingGroupId = 2;
        p.alphaIndex = i;

        p.isPickable = false;
        p.freezeWorldMatrix();

        const speedU = (0.025 + Math.random()*0.004) * (0.7 + (1.0 - t)*0.6);
        const speedV = (0.015 + Math.random()*0.003) * (0.7 + t*0.5);
        const dirU = Math.random() < 0.5 ? -1 : 1;
        const dirV = Math.random() < 0.5 ? -1 : 1;

        fogSlices.push({mat:m, speedU: speedU*dirU, speedV: speedV*dirV});
      }

      const glow = new BABYLON.GlowLayer("glow", scene, { blurKernelSize: 10, mainTextureRatio: 0.5 });
      glow.intensity = 0.5;
      for (let i=0;i<slices;i++){
        const fs = scene.getMeshByName(`fogSlice${i}`);
        if (fs) glow.addExcludedMesh(fs);
      }

      (function makeLava(){
        const lava = BABYLON.MeshBuilder.CreateGround("lava", {
          width: planeWidth, height: planeHeight, subdivisions: 64
        }, scene);
        lava.position = new BABYLON.Vector3(0, floorY + 10.0, 0);
        lava.renderingGroupId = 1;
        lava.isPickable = false;
        lava.freezeWorldMatrix();

        LAVA_Y = lava.position.y;

        const lavaMat = new BABYLON.LavaMaterial("lavaMat", scene);
        lavaMat.noiseTexture  = new BABYLON.Texture("https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lava/cloud.png", scene);
        lavaMat.diffuseTexture = new BABYLON.Texture("https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lava/lavatile.jpg", scene);
        lavaMat.speed = 0.06;
        lavaMat.fogColor = new BABYLON.Color3(0.85, 0.28, 0.08);
        lavaMat.diffuseTexture.uScale = lavaMat.diffuseTexture.vScale = 4;
        lavaMat.noiseTexture.uScale   = lavaMat.noiseTexture.vScale   = 4;
        lavaMat.alpha = 1.0;
        lavaMat.alphaMode = BABYLON.Engine.ALPHA_DISABLE;
        lavaMat.disableDepthWrite = false;
        lavaMat.fogEnabled = true;

        lava.material = lavaMat;

        scene.onBeforeRenderObservable.add(() => {
          const dt = engine.getDeltaTime() / 1000;
          const speed = 0.009;
          if (lavaMat && lavaMat.diffuseTexture) {
            lavaMat.diffuseTexture.uOffset += speed * dt;
          }
          if (lavaMat && lavaMat.noiseTexture) {
            lavaMat.noiseTexture.uOffset += (speed * 0.5) * dt;
          }
        });

        (function addLavaLights(){
          const lavaColor = new BABYLON.Color3(1.0, 0.45, 0.12);

          const spot = new BABYLON.SpotLight(
            "lavaSpot",
            new BABYLON.Vector3(0, LAVA_Y + 0.5, 0),
            new BABYLON.Vector3(0, 1, 0),
            Math.PI * 0.95,
            10,
            scene
          );
          spot.diffuse = lavaColor;
          spot.specular = lavaColor.scale(0.2);
          spot.intensity = 3;
          spot.range = 140;

          const fillIntensity = 1.3;
          const fillRange = 90;

          const fill1 = new BABYLON.PointLight(
            "lavaFillStart",
            new BABYLON.Vector3(beamStart.x, LAVA_Y + 0.8, beamStart.z),
            scene
          );
          fill1.diffuse = lavaColor;
          fill1.specular = lavaColor.scale(0.15);
          fill1.intensity = fillIntensity;
          fill1.range = fillRange;

          const fill2 = new BABYLON.PointLight(
            "lavaFillEnd",
            new BABYLON.Vector3(beamEnd.x, LAVA_Y + 0.8, beamEnd.z),
            scene
          );
          fill2.diffuse = lavaColor;
          fill2.specular = lavaColor.scale(0.15);
          fill2.intensity = fillIntensity;
          fill2.range = fillRange;

          const hemi = new BABYLON.HemisphericLight("lavaHemi", new BABYLON.Vector3(0, -1, 0), scene);
          hemi.diffuse = lavaColor.scale(0.25);
          hemi.specular = new BABYLON.Color3(0,0,0);
          hemi.groundColor = lavaColor.scale(0.55);
          hemi.intensity = 0.55;
        })();
      })();

      // Brisa da névoa
      let acc = 0, step = 1/60;
      scene.onBeforeRenderObservable.add(()=>{
        const dt = engine.getDeltaTime()/1000;
        acc += dt;
        if (acc < step) return;
        for (const s of fogSlices){
          const tex = s.mat.opacityTexture;
          tex.uOffset += s.speedU * acc;
          tex.vOffset += s.speedV * acc;
        }
        acc = 0;
      });
    })();
    // ======== FIM NÉVOA/LAVA ========

    // Blocos de início/fim até a lava
    (function makeEndBlocks(){
      const cfg = { along:10, side:350, bottomExtra:2, tilesPerUnit:1, darkenLevel:0.6 };
      const dir = beamDir.clone().normalize();
      const q = BABYLON.Quaternion.FromLookDirectionLH(dir, BABYLON.Axis.Y);

      function makeFloorMat(name, uTiles, vTiles){
        const m = new BABYLON.StandardMaterial(name, scene);
        const tex = new BABYLON.Texture("https://playground.babylonjs.com/textures/floor.png", scene);
        tex.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE; tex.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
        tex.uScale = Math.max(1, Math.round(uTiles)); tex.vScale = Math.max(1, Math.round(vTiles));
        tex.level  = cfg.darkenLevel;
        m.diffuseTexture = tex; m.specularColor = new BABYLON.Color3(0,0,0);
        return m;
      }

      function makeEndBlock(name, endPoint, dirSign){
        const topY = endPoint.y;
        const bottomY = (LAVA_Y ?? -35) - cfg.bottomExtra;
        const height = topY - bottomY;
        const centerY = bottomY + height * 0.5;

        const box = BABYLON.MeshBuilder.CreateBox(name, {
          width: cfg.side, height: height, depth: cfg.along
        }, scene);

        box.rotationQuaternion = q.clone();

        const offset = dir.scale((cfg.along * 0.5) * dirSign);
        box.position = new BABYLON.Vector3(endPoint.x, centerY, endPoint.z).addInPlace(offset);

        const uTiles = cfg.side * cfg.tilesPerUnit;
        const vTiles = height   * cfg.tilesPerUnit;
        box.material = makeFloorMat(name + "Mat", uTiles, vTiles);

        box.isPickable = false;
        box.renderingGroupId = 0;
        box.freezeWorldMatrix();
        return box;
      }

      makeEndBlock("startBlock", beamStart, -1);
      makeEndBlock("endBlock",   beamEnd,    +1);
    })();

    // ======= LOOP E INPUTS =======
    let gameState = 'menu';
    let angle = 0, omega = 0;
    const K_GRAV = 1.6, K_DAMP = 1.1, K_INPUT = 2.5, K_RESIST = 0.7;
    const MAX_ROLL_FOR_INPUT = 0.6;
    const FALL_LIMIT = 0.9;
    const GAME_OVER_LIMIT = 0.8;

    // SPEED-VAR
    const BASE_SPEED = 1.5;
    let   speedSmoothed = BASE_SPEED * 0.8;
    const MIN_TILT_FACTOR = 0.22;
    const NOISE_STRENGTH  = 0.30;
    const noiseSeedA = Math.random() * Math.PI * 2;
    const noiseSeedB = Math.random() * Math.PI * 2;

    function tiltSpeedFactor(a){
      const x = Math.min(1, Math.abs(a) / FALL_LIMIT);
      const smooth = 1 - (x*x*(3 - 2*x));
      return MIN_TILT_FACTOR + (1 - MIN_TILT_FACTOR) * smooth;
    }
    function temporalNoise(t){
      const n1 = Math.sin(t * 1.7 + noiseSeedA);
      const n2 = Math.sin(t * 0.7 + noiseSeedB);
      return 1 + NOISE_STRENGTH * (0.6*n1 + 0.4*n2);
    }

    // Inputs "play"
    let keyTarget = 0, keyInput = 0;
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'KeyA') keyTarget = 1; else if (e.code === 'KeyD') keyTarget = -1;
    });
    window.addEventListener('keyup', (e)=>{
      if ((e.code === 'KeyA' && keyTarget === 1) || (e.code === 'KeyD' && keyTarget === -1)) keyTarget = 0;
    });

    // Inputs "freecam"
    let freeUp=0, freeDown=0, freeSprint=0;
    function onFreeKeyDown(e){
      if (gameState !== 'freecam') return;
      if (e.code === 'KeyE' || e.code === 'Space') freeUp = 1;
      if (e.code === 'KeyQ' || e.code === 'ControlLeft' || e.code === 'ControlRight') freeDown = 1;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') freeSprint = 1;
      if (e.code === 'Escape'){
        document.exitPointerLock?.();
        menu.classList.remove('hide');
        hud.setAttribute('aria-hidden','true');
      }
    }
    function onFreeKeyUp(e){
      if (e.code === 'KeyE' || e.code === 'Space') freeUp = 0;
      if (e.code === 'KeyQ' || e.code === 'ControlLeft' || e.code === 'ControlRight') freeDown = 0;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') freeSprint = 0;
    }
    window.addEventListener('keydown', onFreeKeyDown);
    window.addEventListener('keyup', onFreeKeyUp);

    function updateMeter(a){
      const max = FALL_LIMIT;
      const percent = (a / max) * 50;
      needle.style.left = `calc(50% + ${percent}%)`;
    }
    function updateSpeedBadgeDisplay(speed){
      if (speedBadge) speedBadge.textContent = `Vel: ${speed.toFixed(2)} u/s`;
    }

    // ======== VR MODE (Cardboard) ========
    let vrMode = false;
    let vrHUDRoot = null, vrHUDTexture = null;
    let vrMenuRoot = null, vrReticle = null;

    async function requestMotionPermission(){
      try{
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
          const r = await DeviceMotionEvent.requestPermission(); if (r !== 'granted') return false;
        }
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
          const r2 = await DeviceOrientationEvent.requestPermission(); if (r2 !== 'granted') return false;
        }
      }catch(_){ }
      return true;
    }

    function swapToDeviceOrientationCamera(){
      const fov = camera.fov ?? 0.8, minZ = camera.minZ ?? 0.1, maxZ = camera.maxZ ?? 1000;
      if (camera){ camera.detachControl(canvas); camera.dispose?.(); }
      const devcam = new BABYLON.DeviceOrientationCamera('devcam', BABYLON.Vector3.Zero(), scene);
      devcam.fov = fov; devcam.minZ = minZ; devcam.maxZ = maxZ;
      devcam.attachControl(canvas, true);
      devcam._disablePointerInputWhenUsingDeviceOrientation = false;
      devcam.parent = rig;
      devcam.position.set(0,0,0);
      scene.activeCamera = devcam;
      camera = devcam;
    }

    function createVRHUD(){
      if (vrHUDRoot) return;
      vrHUDRoot = new BABYLON.TransformNode('vrHUD', scene);
      vrHUDRoot.parent = camera;

      const panel = BABYLON.MeshBuilder.CreatePlane('vrPanel', { width: 0.68, height: 0.22 }, scene);
      panel.parent = vrHUDRoot;
      panel.position = new BABYLON.Vector3(0, -0.2, 0.9);
      panel.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

      const mat = new BABYLON.StandardMaterial('vrPanelMat', scene);
      vrHUDTexture = new BABYLON.DynamicTexture('vrDT', {width:1024, height:256}, scene, true);
      mat.diffuseTexture = vrHUDTexture; mat.emissiveColor = new BABYLON.Color3(0.90,0.94,1.0);
      mat.specularColor = new BABYLON.Color3(0,0,0); mat.backFaceCulling = false;
      panel.material = mat;

      updateVRPanel(0, 0);
    }

    function disposeVRHUD(){
      if (vrHUDRoot){ vrHUDRoot.getChildMeshes().forEach(m=>m.dispose()); vrHUDRoot.dispose(); vrHUDRoot=null; }
      if (vrHUDTexture){ vrHUDTexture.dispose(); vrHUDTexture=null; }
    }

    function updateVRPanel(a, speed){
      if (!vrHUDTexture) return;
      const ctx = vrHUDTexture.getContext(); const s = vrHUDTexture.getSize();
      ctx.clearRect(0,0,s.width,s.height);

      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0, 0, s.width, s.height);

      ctx.fillStyle = '#e6ebf5';
      ctx.font = 'bold 42px system-ui,Segoe UI,Arial';
      ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.fillText('VR HUD', 24, 18);

      ctx.font = 'bold 56px system-ui,Segoe UI,Arial';
      ctx.fillText(`Vel: ${speed.toFixed(2)} u/s`, 24, 84);

      const barX=24, barY=180, barW=s.width-48, barH=24;
      ctx.fillStyle = 'rgba(230,235,245,0.15)';
      ctx.fillRect(barX, barY, barW, barH);

      ctx.fillStyle = '#0b2a6b';
      ctx.fillRect(barX + barW/2 - 2, barY, 4, barH);

      const max = FALL_LIMIT;
      const t = Math.max(-1, Math.min(1, a / max));
      const cx = barX + barW/2 + (barW/2 - 8) * t;
      ctx.fillStyle = '#e6ebf5';
      ctx.fillRect(cx-6, barY-4, 12, barH+8);

      vrHUDTexture.update();
    }

    function makeVRButton(name, text, x, y, onClick){
      const w=0.42, h=0.13;
      const btn = BABYLON.MeshBuilder.CreatePlane(name, {width:w, height:h}, scene);
      btn.position = new BABYLON.Vector3(x, y, 1.2);
      btn.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
      const dt = new BABYLON.DynamicTexture(name+'DT', {width:512, height:160}, scene, true);
      const m  = new BABYLON.StandardMaterial(name+'Mat', scene);
      m.diffuseTexture = dt; m.emissiveColor = new BABYLON.Color3(0.92,0.96,1.0); m.specularColor = new BABYLON.Color3(0,0,0);
      m.backFaceCulling=false; btn.material=m;
      const ctx = dt.getContext(), s = dt.getSize();
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,s.width,s.height);
      ctx.strokeStyle='rgba(230,235,245,0.35)'; ctx.lineWidth=6; ctx.strokeRect(6,6,s.width-12,s.height-12);
      ctx.fillStyle='#e6ebf5'; ctx.font='bold 48px system-ui,Segoe UI,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, s.width/2, s.height/2); dt.update();

      btn.isPickable = true;
      btn.actionManager = new BABYLON.ActionManager(scene);
      btn.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, onClick));
      return btn;
    }

    function createVRMenu(){
      if (vrMenuRoot) return;
      vrMenuRoot = new BABYLON.TransformNode('vrMenuRoot', scene);
      vrMenuRoot.parent = camera;

      const panel = BABYLON.MeshBuilder.CreatePlane('vrMenuPanel', { width: 1.2, height: 0.8 }, scene);
      panel.parent = vrMenuRoot;
      panel.position = new BABYLON.Vector3(0, 0.05, 1.2);
      panel.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
      const mat = new BABYLON.StandardMaterial('vrMenuPanelMat', scene);
      const dt = new BABYLON.DynamicTexture('vrMenuDT', {width:1024, height:700}, scene, true);
      mat.diffuseTexture = dt; mat.emissiveColor = new BABYLON.Color3(0.9,0.94,1.0); mat.backFaceCulling = false;
      panel.material = mat;
      const ctx = dt.getContext(), s=dt.getSize();
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,s.width,s.height);
      ctx.fillStyle='#e6ebf5'; ctx.font='bold 60px system-ui,Segoe UI,Arial'; ctx.textAlign='center'; ctx.textBaseline='top';
      ctx.fillText('Menu (VR)', s.width/2, 24);
      ctx.font='bold 28px system-ui,Segoe UI,Arial';
      ctx.fillText('Olhe para um botão e toque na tela para selecionar', s.width/2, 110);
      dt.update();

      // Botões
      const btnPlay = makeVRButton('btnVRPlay','Jogar', -0.38, -0.10, ()=>{
        disposeVRMenu();
        createVRHUD();
        hud.setAttribute('aria-hidden','true');
        meter.style.display = 'none';
        startCountdownThenRun();
      });
      const btnFree = makeVRButton('btnVRFree','Free Cam (off)', 0.0, -0.10, ()=>{
        // desabilitado no VR
      });
      const btnExit = makeVRButton('btnVRExit','Sair do VR', 0.38, -0.10, ()=>{
        exitCardboardVR();
      });
      btnPlay.parent = vrMenuRoot; btnFree.parent = vrMenuRoot; btnExit.parent = vrMenuRoot;

      // Retículo
      const retDT = new BABYLON.DynamicTexture('reticleDT', {width:64, height:64}, scene, true);
      const rc = retDT.getContext(); const rs = retDT.getSize();
      rc.clearRect(0,0,rs.width,rs.height);
      rc.strokeStyle='rgba(200,255,200,0.9)'; rc.lineWidth=4;
      rc.beginPath(); rc.arc(rs.width/2, rs.height/2, 20, 0, Math.PI*2); rc.stroke();
      retDT.update();
      const ret = BABYLON.MeshBuilder.CreatePlane('reticle', {width:0.03, height:0.03}, scene);
      const retM = new BABYLON.StandardMaterial('retM', scene);
      retM.diffuseTexture = retDT; retM.emissiveColor = new BABYLON.Color3(0.8,1,0.8); retM.backFaceCulling=false;
      ret.material = retM; ret.position = new BABYLON.Vector3(0, 0, 0.9);
      ret.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
      ret.parent = camera;
      vrReticle = ret;

      // Tap em qualquer lugar = pick no centro
      scene.onPointerObservable.add((info)=>{
        if(info.type === BABYLON.PointerEventTypes.POINTERDOWN){
          const pick = scene.pick(scene.getEngine().getRenderWidth()/2, scene.getEngine().getRenderHeight()/2);
          if (pick && pick.pickedMesh && pick.pickedMesh.actionManager){
            pick.pickedMesh.actionManager.processTrigger(BABYLON.ActionManager.OnPickTrigger, {});
          }
        }
      });
    }

    function disposeVRMenu(){
      if (!vrMenuRoot) return;
      vrMenuRoot.getChildren().forEach(n=>n.dispose?.());
      vrMenuRoot.getChildMeshes().forEach(m=>m.dispose());
      vrMenuRoot.dispose(); vrMenuRoot=null;
      if (vrReticle){ vrReticle.dispose(); vrReticle=null; }
    }

    async function enterCardboardVR(){
      if (!isMobile) { alert('Modo VR disponível apenas no celular.'); return; }
      const ok = await requestMotionPermission(); if (!ok) { alert('Permissão do giroscópio negada.'); return; }

      vrMode = true;
      // Fica no MENU (não inicia jogo)
      gameState = 'menu';

      // Esconde HUD/Menu DOM e usa menu 3D
      hud.setAttribute('aria-hidden','true');
      menu.classList.add('hide');
      meter.style.display = 'none';

      // Câmera orientação + estéreo side-by-side
      swapToDeviceOrientationCamera();
      try{
        camera.setCameraRigMode(BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, { interaxialDistance: 0.0635 });
      }catch(_){}

      // Fullscreen + landscape
      try{ await canvas.requestFullscreen?.(); }catch(_){}
      try{ await screen.orientation?.lock?.('landscape'); }catch(_){}

      // Menu VR
      createVRMenu();
      setTimeout(()=>engine.resize(),0);
    }

    async function exitCardboardVR(){
      // Desfaz UI VR
      disposeVRHUD();
      disposeVRMenu();

      // Volta pro menu DOM
      menu.classList.remove('hide');
      hud.setAttribute('aria-hidden','true'); // no menu
      meter.style.display = '';

      // Sai do rig estéreo
      try{ camera.setCameraRigMode(BABYLON.Camera.RIG_MODE_NONE, {}); }catch(_){}
      // Restaura câmera normal
      if (camera){ camera.detachControl(canvas); camera.parent = rig; camera.position.set(0,0,0); }
      // Tenta sair de fullscreen/orientation
      try{ await document.exitFullscreen?.(); }catch(_){}
      try{ await screen.orientation?.unlock?.(); }catch(_){}

      vrMode = false;
      gameState = 'menu';
      setTimeout(()=>engine.resize(),0);
    }

    // HUD: orientação
    function refreshOrientationBadge(){
      const isLandscape = window.matchMedia('(orientation: landscape)').matches;
      orientBadge.textContent = isLandscape ? 'Landscape' : 'Portrait';
    }
    refreshOrientationBadge();
    window.matchMedia('(orientation: landscape)').addEventListener?.('change', refreshOrientationBadge);

    // ====== LOOP ======
    engine.runRenderLoop(()=>{
      const dt = engine.getDeltaTime() / 1000;
      const t  = performance.now() / 1000;

      if (gameState === 'running'){
        keyInput += (keyTarget - keyInput) * Math.min(1, dt*8);

        let userInput = keyInput;
        if (isMobile && camera.rotationQuaternion){
          const e = camera.rotationQuaternion.toEulerAngles();
          const phoneRoll = e.z;
          const norm = Math.max(-1, Math.min(1, phoneRoll / MAX_ROLL_FOR_INPUT));
          userInput = norm;
        }
        const effective = userInput / (1 + K_RESIST * Math.abs(angle));

        const acc = K_GRAV * Math.sin(angle) - K_DAMP * omega - K_INPUT * effective;
        omega += acc * dt;
        angle += omega * dt;
        rig.rotation.z = angle;

        if (!vrMode) updateMeter(angle);

        if (Math.abs(angle) >= GAME_OVER_LIMIT){
          triggerGameOver();
          return;
        }

        const tiltFactor = tiltSpeedFactor(angle);
        const randFactor = temporalNoise(t);
        const targetSpeed = BASE_SPEED * tiltFactor * randFactor;
        const lerp = Math.min(1, dt * 3.5);
        speedSmoothed += (targetSpeed - speedSmoothed) * lerp;

        if (vrMode) updateVRPanel(angle, speedSmoothed);
        else updateSpeedBadgeDisplay(speedSmoothed);

        const toCube = cube.position.subtract(rig.position);
        const dist = toCube.length();
        if (dist > 1.6){
          toCube.normalize();
          rig.position.addInPlace(toCube.scale(speedSmoothed * dt));
        }
      } else if (gameState === 'freecam'){
        const fc = camera;
        if (fc){
          fc.speed = freeSprint ? 7.0 : 3.0;
          const dy = (freeUp - freeDown) * fc.speed * dt * 3.0;
          fc.position.y += dy;
        }
      }

      scene.render();
    });

    window.addEventListener('resize', () => {
      engine.resize();
      engine.setHardwareScalingLevel(isMobile ? 1.25 : 1.0);
    });

    // UI: fluxo
    function startCountdownThenRun(){
      gameState = 'countdown';
      const plane = BABYLON.MeshBuilder.CreatePlane('countPlane', { size: 1.4 }, scene);
      plane.position = cube.position.add(new BABYLON.Vector3(0, 1.6, 0));
      plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
      const dt = new BABYLON.DynamicTexture('countDT', {width:512, height:512}, scene, true);
      const mat = new BABYLON.StandardMaterial('countMat', scene);
      mat.diffuseTexture = dt; mat.emissiveColor = new BABYLON.Color3(0.92,0.96,1.0); mat.specularColor = new BABYLON.Color3(0,0,0); mat.backFaceCulling = false;
      plane.material = mat;
      const draw = (n)=>{
        const ctx = dt.getContext(); const s = dt.getSize();
        ctx.clearRect(0,0,s.width,s.height);
        ctx.fillStyle = '#e6ebf5'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font = 'bold 340px system-ui,Segoe UI,Arial';
        ctx.fillText(String(n), s.width/2, s.height/2);
        dt.update();
      };
      let n = 3; draw(n);
      const id = setInterval(()=>{
        n--; if (n>0){ draw(n); } else { clearInterval(id); plane.dispose(); gameState='running'; }
      }, 1000);
    }

    function triggerGameOver(){
      gameState = 'gameover';
      if (!vrMode){
        hud.setAttribute('aria-hidden','true');
        gameover.classList.remove('hide');
      } else {
        const plane = BABYLON.MeshBuilder.CreatePlane('vrGameOver', { width: 0.8, height: 0.26 }, scene);
        plane.parent = camera; plane.position = new BABYLON.Vector3(0, 0, 1.2);
        const dt = new BABYLON.DynamicTexture('vrGOdt', {width:1024, height:320}, scene, true);
        const mat = new BABYLON.StandardMaterial('vrGOmat', scene);
        mat.diffuseTexture = dt; mat.emissiveColor = new BABYLON.Color3(1,0.3,0.3); mat.backFaceCulling = false;
        plane.material = mat;
        const ctx = dt.getContext(), s = dt.getSize();
        ctx.clearRect(0,0,s.width,s.height);
        ctx.fillStyle='#000'; ctx.globalAlpha=0.6; ctx.fillRect(0,0,s.width,s.height); ctx.globalAlpha=1;
        ctx.fillStyle='#ffb3b3'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font='bold 120px system-ui,Segoe UI,Arial';
        ctx.fillText('GAME OVER', s.width/2, s.height/2);
        dt.update();
      }
    }

    restart.addEventListener('click', () => {
      gameover.classList.add('hide');
      hud.setAttribute('aria-hidden','false');
      meter.style.display = '';
      rig.position.copyFrom(new BABYLON.Vector3(0, 1.2, 38));
      rig.rotation.set(0,0,0);
      angle = 0; omega = 0;
      speedSmoothed = BASE_SPEED * 0.8;
      if (camera.rotationQuaternion) {
        camera.rotationQuaternion.copyFrom(BABYLON.Quaternion.Identity());
      }
      updateSpeedBadgeDisplay(speedSmoothed);
      startCountdownThenRun();
    });

    play.addEventListener('click', async () => {
      menu.classList.add('hide');
      hud.setAttribute('aria-hidden','false');
      meter.style.display = '';
      if (isMobile) { const ok = await requestMotionPermission(); if (ok) swapToDeviceOrientationCamera(); }
      else { canvas.requestPointerLock?.(); swapToDeviceOrientationCamera(); }
      setTimeout(() => engine.resize(), 0);
      updateSpeedBadgeDisplay(speedSmoothed);
      startCountdownThenRun();
    }, { passive:true });

    freeBtn.addEventListener('click', () => {
      if (vrMode) return; // Freecam desabilitado em VR
      menu.classList.add('hide');
      hud.setAttribute('aria-hidden','true');
      meter.style.display = 'none';
      gameState = 'freecam';
      const fov = camera.fov ?? 0.8;
      if (camera){ camera.detachControl(canvas); camera.parent = null; camera.dispose?.(); }
      const fc = new BABYLON.FreeCamera('freecam', new BABYLON.Vector3(0, 2.2, 45), scene);
      fc.fov = fov; fc.minZ = 0.1; fc.maxZ = 1000;
      fc.rotation = new BABYLON.Vector3(0, 0, 0);
      fc.setTarget(beamMid);
      fc.keysUp=[87,38]; fc.keysDown=[83,40]; fc.keysLeft=[65,37]; fc.keysRight=[68,39];
      fc.speed = 3.0; fc.inertia = 0.8; fc.angularSensibility = 1300;
      fc.attachControl(canvas, true);
      scene.activeCamera = fc;
      camera = fc;
      if (!isMobile) canvas.requestPointerLock?.();
      setTimeout(() => engine.resize(), 0);
    }, { passive:true });

    vrBtn.addEventListener('click', async () => {
      await enterCardboardVR();
      // permanece no MENU VR (não inicia o jogo aqui)
    }, { passive:true });

  })();
  </script>
</body>
</html>
