<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <title>FPS 3D — Protótipo (Menu + HUD + Gyro + Corda + Balance)</title>
  <style>
    :root{ --navy:#0b2a6b; --navy2:#001021; --fg:#e6ebf5; }
    html,body{ height:100%; margin:0; background:#000; color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body{ height:100dvh; }
    canvas{ width:100vw; height:100dvh; display:block; touch-action:none; }

    /* ===== Overlay base ===== */
    #menu, #gameover{
      position:fixed; inset:0; display:grid; place-items:center; z-index:3;
      background:
        linear-gradient(180deg, rgba(0,16,33,.66), rgba(0,0,0,.68)),
        radial-gradient(700px 500px at 50% 18%, rgba(11,42,107,.22), rgba(0,0,0,0) 60%);
      -webkit-backdrop-filter: blur(4px) saturate(1.05);
      backdrop-filter: blur(4px) saturate(1.05);
      transition: opacity .6s ease, visibility .6s ease;
    }
    #menu.hide, #gameover.hide{ opacity:0; visibility:hidden; }

    .panel{ padding:28px 28px 22px; border-radius:18px; width:min(92vw, 520px);
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.22));
      border:1px solid rgba(255,255,255,.06); box-shadow: 0 20px 60px rgba(0,0,0,.55);
      text-align:center; }
    .panel h1{ margin:0 0 .5rem; font-size: clamp(26px, 5vw, 40px); letter-spacing:.4px; }
    .panel p{ margin:.25rem 0 1.25rem; opacity:.8; font-size: clamp(14px, 2.2vw, 16px); }

    .btn{ appearance:none; border:none; cursor:pointer; padding:14px 28px; font-weight:800; font-size:16px; border-radius:14px;
      background: linear-gradient(135deg, var(--navy2) 0%, var(--navy) 100%);
      color:var(--fg); box-shadow: 0 12px 34px rgba(11,42,107,.40), inset 0 1px 0 rgba(255,255,255,.07);
      transition: transform .15s ease, box-shadow .2s ease, filter .2s ease; }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 16px 42px rgba(11,42,107,.55), inset 0 1px 0 rgba(255,255,255,.09); }
    .btn:active{ transform: translateY(0); filter: brightness(.96); }

    /* ===== HUD ===== */
    .hud{ position:fixed; inset:0; z-index:2; pointer-events:none;
      padding: calc(env(safe-area-inset-top,0px) + 8px) calc(env(safe-area-inset-right,0px) + 12px) calc(env(safe-area-inset-bottom,0px) + 8px) calc(env(safe-area-inset-left,0px) + 12px);
      display:flex; flex-direction:column; justify-content:space-between; }
    .hud .row{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .hud .left,.hud .right{ display:flex; align-items:center; gap:10px; }
    .hud .badge{ pointer-events:none; opacity:.75; font-weight:700; font-size:12px; padding:6px 8px; border-radius:10px;
      background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.08); }

    @media (orientation: landscape){
      .hud{ padding-left: calc(env(safe-area-inset-left,0px) + 18px); padding-right: calc(env(safe-area-inset-right,0px) + 18px); }
    }

    /* ===== Game Over ===== */
    #gameover{
      z-index:4;
      background:
        linear-gradient(180deg, rgba(0,0,0,.88), rgba(0,0,0,.92)),
        radial-gradient(700px 500px at 50% 18%, rgba(11,42,107,.22), rgba(0,0,0,0) 60%);
    }

    /* ===== Régua de Equilíbrio ===== */
    .meter {
      width: 120px;
      height: 10px;
      border-radius: 12px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.08);
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 1px 2px rgba(0,0,0,.5);
    }
    .meter .track { width: 100%; height: 100%; position: relative; }
    .meter .centerMark {
      position: absolute; top: 50%; left: 50%;
      width: 2px; height: 70%;
      background: var(--navy);
      transform: translate(-50%, -50%);
      border-radius: 2px; opacity: .85;
    }
    .meter .needle {
      position: absolute; top: 50%; left: 50%;
      width: 8px; height: 70%;
      background: var(--fg);
      border-radius: 3px;
      transform: translate(-50%, -50%);
      transition: left 0.05s linear;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- MENU -->
  <div id="menu" aria-modal="true" role="dialog">
    <div class="panel" aria-label="Menu inicial">
      <h1>FPS 3D • Protótipo</h1>
      <p>Pronto para mobile e desktop. Em celulares, o <b>giroscópio</b> liga automaticamente.</p>
      <button id="play" class="btn" aria-label="Jogar">Jogar</button>
    </div>
  </div>

  <!-- GAME OVER -->
  <div id="gameover" aria-modal="true" role="dialog" class="hide">
    <div class="panel" aria-label="Tela de Game Over">
      <h1>Game Over</h1>
      <p>Você perdeu o equilíbrio.</p>
      <button id="restart" class="btn" aria-label="Reiniciar">Reiniciar</button>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud" id="hud" aria-hidden="true">
    <div class="row top">
      <div class="left"><span class="badge">FPS 3D</span></div>
      <div class="right controls">
        <div id="balanceMeter" class="meter">
          <div class="track">
            <div class="centerMark"></div>
            <div class="needle"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="row bottom">
      <div class="left"></div>
      <div class="right"><span class="badge" id="orientBadge">—</span></div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const menu   = document.getElementById('menu');
    const play   = document.getElementById('play');
    const hud    = document.getElementById('hud');
    const orientBadge = document.getElementById('orientBadge');
    const gameover = document.getElementById('gameover');
    const restart  = document.getElementById('restart');
    const needle = document.querySelector('#balanceMeter .needle');

    // Detecção simples de mobile
    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 1 && screen.width < 1025);

    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0,0,0,1);

    // ===== Cena base =====
    let camera = new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(0, 1.2, 38), scene);
    camera.attachControl(canvas, true);
    camera.speed = 0;
    camera.keysUp = camera.keysDown = camera.keysLeft = camera.keysRight = [];

    const rig = new BABYLON.TransformNode('playerRig', scene);
    rig.position.copyFrom(camera.position);
    camera.parent = rig;
    camera.position.set(0,0,0);

    const light = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0,1,0), scene);
    light.intensity = 0.9;

    const room = BABYLON.MeshBuilder.CreateBox('room', { size: 80, sideOrientation: BABYLON.Mesh.BACKSIDE }, scene);
    const roomMat = new BABYLON.StandardMaterial('roomMat', scene);
    roomMat.diffuseColor = new BABYLON.Color3(0.06, 0.07, 0.10);
    roomMat.specularColor = new BABYLON.Color3(0, 0, 0);
    room.material = roomMat;

    const cube = BABYLON.MeshBuilder.CreateBox('cube', { size: 1 }, scene);
    cube.position = new BABYLON.Vector3(0, 0.5, -30);
    const crateMat = new BABYLON.StandardMaterial('crateMat', scene);
    crateMat.diffuseTexture = new BABYLON.Texture('https://playground.babylonjs.com/textures/crate.png', scene);
    crateMat.specularColor = new BABYLON.Color3(0.1,0.1,0.1);
    cube.material = crateMat;

    // ===== Viga =====
    const beamY = 0.12;
    const endOffsetY = -0.65;
    const beamStart = new BABYLON.Vector3(rig.position.x, beamY, rig.position.z);
    const beamEnd   = new BABYLON.Vector3(cube.position.x, beamY + endOffsetY, cube.position.z);
    const beamDir   = beamEnd.subtract(beamStart);
    const beamLen   = beamDir.length();
    const beamMid   = beamStart.add(beamEnd).scale(0.5);

    const beam = BABYLON.MeshBuilder.CreateBox('beam', { width:0.15, height:0.08, depth:beamLen }, scene);
    beam.position = beamMid;
    beam.lookAt(beamEnd);

    const metalMat = new BABYLON.StandardMaterial('metalMat', scene);
    metalMat.diffuseTexture = new BABYLON.Texture('https://playground.babylonjs.com/textures/reflectivity.png', scene);
    metalMat.diffuseColor = new BABYLON.Color3(0.25, 0.28, 0.32);
    metalMat.specularColor = new BABYLON.Color3(0.08, 0.08, 0.10);
    metalMat.specularPower = 32;
    if (metalMat.diffuseTexture){
      metalMat.diffuseTexture.level = 0.75;
      metalMat.diffuseTexture.uScale = Math.max(1, beamLen / 4);
      metalMat.diffuseTexture.vScale = 1;
    }
    beam.material = metalMat;

    // <<< COLE AQUI >>>
    (function makeGroundFog(){
      const roomSize = 80;            // seu box tem size 80 → piso interno em y = -40
      const floorY   = -40;
      const fogY     = floorY + 0.8;  // altura base da névoa, levemente acima do piso
      const margin   = 6;             // margem das paredes p/ evitar clipping na box

      const fog = BABYLON.GPUParticleSystem && BABYLON.GPUParticleSystem.IsSupported
        ? new BABYLON.GPUParticleSystem("groundFog", { capacity: 6000 }, scene)
        : new BABYLON.ParticleSystem("groundFog", 6000, scene);

      fog.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);

      fog.emitter   = new BABYLON.Vector3(0, fogY, 0);
      const half = roomSize * 0.5 - margin;
      fog.minEmitBox = new BABYLON.Vector3(-half, 0, -half);
      fog.maxEmitBox = new BABYLON.Vector3( half, 0,  half);

      fog.color1 = new BABYLON.Color4(1.0, 0.45, 0.18, 0.10);
      fog.color2 = new BABYLON.Color4(1.0, 0.25, 0.05, 0.08);
      fog.colorDead = new BABYLON.Color4(1, 0.2, 0.0, 0.0);

      fog.minSize = 1.2; fog.maxSize = 3.8;
      fog.minLifeTime = 3.0; fog.maxLifeTime = 7.0;
      fog.emitRate = 800;

      fog.gravity = new BABYLON.Vector3(0, -0.02, 0);
      fog.direction1 = new BABYLON.Vector3(-0.25, 0.05, -0.25);
      fog.direction2 = new BABYLON.Vector3( 0.25, 0.00,  0.25);
      fog.minAngularSpeed = -0.2; fog.maxAngularSpeed = 0.2;
      fog.minEmitPower = 0.05; fog.maxEmitPower = 0.15;
      fog.updateSpeed = 0.015;
      fog.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;

      const maxFogHeight = 3.0;
      const _updateFunc = fog.updateFunction;
      fog.updateFunction = function(particles){
        _updateFunc.call(fog, particles);
        for (let p of particles) {
          if (!p || !p.position) continue;
          const h = p.position.y - floorY;
          if (h > maxFogHeight) p.age = p.lifeTime;
        }
      };

      fog.start();

      const glow = new BABYLON.GlowLayer("glow", scene, { blurKernelSize: 16 });
      glow.intensity = 0.35;

      const heatPlane = BABYLON.MeshBuilder.CreatePlane("heat", { size: roomSize - margin*2 }, scene);
      heatPlane.position = new BABYLON.Vector3(0, floorY + 0.05, 0);
      heatPlane.rotation.x = Math.PI / 2;
      const heatMat = new BABYLON.StandardMaterial("heatMat", scene);
      heatMat.disableLighting = true;
      heatMat.emissiveColor = new BABYLON.Color3(1.0, 0.25, 0.06);
      heatMat.alpha = 0.05;
      heatMat.backFaceCulling = false;
      heatPlane.material = heatMat;
    })();
    // <<< FIM DA NÉVOA >>>

    engine.runRenderLoop(() => scene.render());
    window.addEventListener('resize', () => engine.resize());

    // ===== HUD: orientação
    function refreshOrientationBadge(){
      const isLandscape = window.matchMedia('(orientation: landscape)').matches;
      orientBadge.textContent = isLandscape ? 'Landscape' : 'Portrait';
    }
    refreshOrientationBadge();
    window.matchMedia('(orientation: landscape)').addEventListener?.('change', refreshOrientationBadge);

    // ===== Giroscópio
    let yawOffset = (isMobile ? Math.PI / 2 : 0), pitchOffset = 0, rollOffset = 0;

    async function requestMotionPermission(){
      try{
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
          const r = await DeviceMotionEvent.requestPermission(); if (r !== 'granted') return false;
        }
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
          const r2 = await DeviceOrientationEvent.requestPermission(); if (r2 !== 'granted') return false;
        }
      }catch(_){ }
      return true;
    }

    function swapToDeviceOrientationCamera(){
      const fov = camera.fov, minZ = camera.minZ, maxZ = camera.maxZ;
      const devcam = new BABYLON.DeviceOrientationCamera('devcam', BABYLON.Vector3.Zero(), scene);
      devcam.fov = fov; devcam.minZ = minZ; devcam.maxZ = maxZ;
      devcam.attachControl(canvas, true);
      devcam._disablePointerInputWhenUsingDeviceOrientation = false;
      devcam.parent = rig; devcam.position.set(0,0,0);

      scene.activeCamera = devcam;
      camera.detachControl(canvas); camera.dispose(); camera = devcam;

      camera.onAfterCheckInputsObservable.clear();
      camera.onAfterCheckInputsObservable.add(() => {
        const q = camera.rotationQuaternion; if (!q) return;
        const adjust = BABYLON.Quaternion.FromEulerAngles(pitchOffset, yawOffset, rollOffset);
        const finalQ = adjust.multiply(q);
        camera.rotationQuaternion.copyFrom(finalQ);
      });
    }

    async function enableGyroAuto(){
      const ok = await requestMotionPermission(); if (!ok) return;
      swapToDeviceOrientationCamera();
    }

    // ===== Input PC
    let keyTarget = 0, keyInput = 0;
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'KeyA') keyTarget = 1; else if (e.code === 'KeyD') keyTarget = -1;
    });
    window.addEventListener('keyup', (e)=>{
      if ((e.code === 'KeyA' && keyTarget === 1) || (e.code === 'KeyD' && keyTarget === -1)) keyTarget = 0;
    });

    // ===== Contador
    function startCountdownThenRun(){
      gameState = 'countdown';
      const plane = BABYLON.MeshBuilder.CreatePlane('countPlane', { size: 1.4 }, scene);
      plane.position = cube.position.add(new BABYLON.Vector3(0, 1.6, 0));
      plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
      const dt = new BABYLON.DynamicTexture('countDT', {width:512, height:512}, scene, true);
      const mat = new BABYLON.StandardMaterial('countMat', scene);
      mat.diffuseTexture = dt; mat.emissiveColor = new BABYLON.Color3(0.92,0.96,1.0); mat.specularColor = new BABYLON.Color3(0,0,0); mat.backFaceCulling = false;
      plane.material = mat;
      const draw = (n)=>{
        const ctx = dt.getContext(); const s = dt.getSize();
        ctx.clearRect(0,0,s.width,s.height);
        ctx.fillStyle = '#e6ebf5'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font = 'bold 340px system-ui,Segoe UI,Arial';
        ctx.fillText(String(n), s.width/2, s.height/2);
        dt.update();
      };
      let n = 3; draw(n);
      const id = setInterval(()=>{
        n--; if (n>0){ draw(n); } else { clearInterval(id); plane.dispose(); gameState='running'; }
      }, 1000);
    }

    // ===== Mecânica de equilíbrio
    let gameState = 'menu';
    let angle = 0, omega = 0;
    const K_GRAV = 1.6, K_DAMP = 1.1, K_INPUT = 2.5, K_RESIST = 0.7;
    const MAX_ROLL_FOR_INPUT = 0.6;
    const FALL_LIMIT = 0.9;
    const GAME_OVER_LIMIT = isMobile ? 0.8 : 0.8;
    const SPEED = 2.0;

    function updateMeter(angle){
      const max = FALL_LIMIT;
      const percent = (angle / max) * 50;
      needle.style.left = `calc(50% + ${percent}%)`;
    }

    engine.runRenderLoop(()=>{
      const dt = engine.getDeltaTime() / 1000;
      keyInput += (keyTarget - keyInput) * Math.min(1, dt*8);

      if (gameState === 'running'){
        let userInput = keyInput;
        if (isMobile && camera.rotationQuaternion){
          const e = camera.rotationQuaternion.toEulerAngles();
          const phoneRoll = e.z;
          const norm = Math.max(-1, Math.min(1, phoneRoll / MAX_ROLL_FOR_INPUT));
          userInput = norm; // não invertido
        }
        const effective = userInput / (1 + K_RESIST * Math.abs(angle));

        const acc = K_GRAV * Math.sin(angle) - K_DAMP * omega - K_INPUT * effective;
        omega += acc * dt;
        angle += omega * dt;
        rig.rotation.z = angle;

        updateMeter(angle);

        if (Math.abs(angle) >= GAME_OVER_LIMIT){
          triggerGameOver();
          return;
        }

        const toCube = cube.position.subtract(rig.position);
        const dist = toCube.length();
        if (dist > 1.6){
          toCube.normalize();
          rig.position.addInPlace(toCube.scale(SPEED * dt));
        }
      }
    });

    // ===== Game Over
    function triggerGameOver(){
      gameState = 'gameover';
      hud.setAttribute('aria-hidden','true');
      gameover.classList.remove('hide');
    }

    restart.addEventListener('click', () => {
      gameover.classList.add('hide');
      hud.setAttribute('aria-hidden','false');
      rig.position.copyFrom(new BABYLON.Vector3(0, 1.2, 38));
      rig.rotation.set(0,0,0);
      angle = 0; omega = 0;
      if (camera.rotationQuaternion) {
        camera.rotationQuaternion.copyFrom(BABYLON.Quaternion.Identity());
      }
      startCountdownThenRun();
    });

    // ===== Menu → iniciar
    play.addEventListener('click', async () => {
      menu.classList.add('hide');
      hud.setAttribute('aria-hidden','false');
      if (isMobile) { await enableGyroAuto(); } else { canvas.requestPointerLock?.(); }
      setTimeout(() => engine.resize(), 0);
      startCountdownThenRun();
    }, { passive:true });
  })();
  </script>
</body>
</html>



