<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Balanço na Corda 3D — VR Ajustável</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: black; font-family: system-ui, sans-serif; }
    canvas { display: block; }
    #hud { position: fixed; top: 0; left: 0; right: 0; padding: 10px; display: flex; align-items: center; gap: 10px; pointer-events: none; z-index: 2; }
    .bar { flex: 1; height: 8px; background: rgba(255,255,255,0.15); border-radius: 999px; overflow: hidden; }
    .fill { height: 100%; background: linear-gradient(90deg, #7bdcff, #91ffb1); width: 0%; }
    .chip { background: rgba(255,255,255,0.08); padding: 4px 10px; border-radius: 999px; font-size: 12px; color:#eee; }
    #overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); color: white; text-align: center; transition: opacity 1s; z-index: 3; }
    #panel { background: rgba(0,0,0,0.85); padding: 20px; border-radius: 12px; max-width: 600px; }
    button { margin-top: 12px; padding: 10px 16px; background: #222; color: #eee; border: 1px solid #555; border-radius: 8px; cursor: pointer; font-weight: bold; }
    button:hover { background: #333; }
    [hidden] { display: none !important; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="chip">VR Box: ajuste IPD • FOV • Convergência</div>
    <div class="bar"><div class="fill" id="fill"></div></div>
    <div class="chip" id="status">Pronto</div>
  </div>

  <div id="overlay">
    <div id="panel">
      <h1>Balanço na Corda 3D — VR Ajustável</h1>
      <p>Agora você pode ajustar parâmetros iguais ao app do VR Box:<br>
      <b>IPD</b> (distância entre olhos), <b>convergência</b>, <b>offset</b>, <b>FOV</b> e <b>distorção</b>.</p>
      <button id="play">Jogar</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
  <script>
  (() => {
    // ====== Parâmetros ajustáveis ======
    let ipd = 0.015;           // distância interpupilar
    let convergence = 0.5    // rotação angular (toe-in) em radianos
    let lensK = 0.18;          // distorção de lente
    let eyeOffsetX = 0.0;      // deslocamento horizontal
    let eyeOffsetY = 0.0;      // deslocamento vertical
    let fov = 95;              // campo de visão
    // ================================

    let scene, renderer;
    let headCam, leftCam, rightCam;
    let rope, floor;

    let rtLeft, rtRight;
    let postScene, postCam, leftQuad, rightQuad, leftMat, rightMat;

    let angle = 0, angVel = 0;
    const maxAngle = 0.5;
    const damping = 0.985;
    const baseControlPower = 1.5;
    let drift = 0, driftTarget = 0, driftTimer = 0;

    const keys = { a: false, d: false };
    const overlay = document.getElementById('overlay');
    const playBtn = document.getElementById('play');
    const fillEl = document.getElementById('fill');
    const statusEl = document.getElementById('status');

    let progress = 0;
    let baseSpeed = 0.05;
    let gameOverFlag = false;
    let gameReady = false;

    let yaw = 0, pitch = 0;
    let sensitivity = 0.002;
    let pointerLocked = false;

    playBtn.onclick = start;

    function start() {
      overlay.style.opacity = 0;
      setTimeout(() => overlay.hidden = true, 1000);
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(()=>{});
      }
      init();
      animate();
    }

    function init() {
      scene = new THREE.Scene();
      headCam = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.05, 1000);
      headCam.position.set(0, 1.6, 5);

      leftCam  = new THREE.PerspectiveCamera(fov, 0.5 * window.innerWidth / window.innerHeight, 0.05, 1000);
      rightCam = new THREE.PerspectiveCamera(fov, 0.5 * window.innerWidth / window.innerHeight, 0.05, 1000);

      renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      document.body.appendChild(renderer.domElement);

      const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
      scene.add(light);

      const floorGeo = new THREE.PlaneGeometry(400, 400, 20, 20);
      const floorMat = new THREE.MeshBasicMaterial({ color: 0xff3300, wireframe: true });
      floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -5;
      scene.add(floor);

      const ropeGeo = new THREE.BoxGeometry(0.1, 0.05, 200);
      const ropeMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
      rope = new THREE.Mesh(ropeGeo, ropeMat);
      scene.add(rope);

      // Render targets
      const rtOpts = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
      rtLeft  = new THREE.WebGLRenderTarget(Math.floor(window.innerWidth/2), window.innerHeight, rtOpts);
      rtRight = new THREE.WebGLRenderTarget(Math.floor(window.innerWidth/2), window.innerHeight, rtOpts);

      // Pós-processamento (distorção)
      postScene = new THREE.Scene();
      postCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      const quadGeo = new THREE.PlaneGeometry(1, 1);

      const lensShader = {
        uniforms: {
          map: { value: null },
          k: { value: lensK },
          aspect: { value: window.innerWidth / window.innerHeight }
        },
        vertexShader: `varying vec2 vUv;
          void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
          uniform sampler2D map;
          uniform float k;
          uniform float aspect;
          varying vec2 vUv;
          vec2 barrel(vec2 uv){
            vec2 p = uv * 2.0 - 1.0;
            p.x *= aspect;
            float r2 = dot(p, p);
            vec2 p2 = p * (1.0 + k * r2);
            p2.x /= aspect;
            return (p2 + 1.0) * 0.5;
          }
          void main(){
            vec2 uv2 = barrel(vUv);
            if(uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0) discard;
            gl_FragColor = texture2D(map, uv2);
          }`
      };

      leftMat  = new THREE.ShaderMaterial({ uniforms: THREE.UniformsUtils.clone(lensShader.uniforms), vertexShader: lensShader.vertexShader, fragmentShader: lensShader.fragmentShader });
      rightMat = new THREE.ShaderMaterial({ uniforms: THREE.UniformsUtils.clone(lensShader.uniforms), vertexShader: lensShader.vertexShader, fragmentShader: lensShader.fragmentShader });
      leftMat.uniforms.map.value  = rtLeft.texture;
      rightMat.uniforms.map.value = rtRight.texture;

      leftQuad  = new THREE.Mesh(quadGeo, leftMat);
      rightQuad = new THREE.Mesh(quadGeo, rightMat);
      leftQuad.position.set(-0.5, 0, 0);
      rightQuad.position.set(0.5, 0, 0);
      leftQuad.scale.set(1, 2, 1);
      rightQuad.scale.set(1, 2, 1);
      postScene.add(leftQuad);
      postScene.add(rightQuad);

      window.addEventListener('resize', onResize);
    }

    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      headCam.aspect = window.innerWidth / window.innerHeight;
      headCam.updateProjectionMatrix();
      leftCam.aspect = rightCam.aspect = 0.5 * window.innerWidth / window.innerHeight;
      leftCam.updateProjectionMatrix();
      rightCam.updateProjectionMatrix();
      rtLeft.setSize(Math.floor(window.innerWidth/2), window.innerHeight);
      rtRight.setSize(Math.floor(window.innerWidth/2), window.innerHeight);
    }

    function updateStereoCameras() {
      headCam.rotation.set(pitch, yaw, angle);
      const forward = new THREE.Vector3();
      headCam.getWorldDirection(forward).normalize();
      const up = new THREE.Vector3(0,1,0).applyQuaternion(headCam.quaternion);
      const right = new THREE.Vector3().crossVectors(forward, up).normalize().multiplyScalar(-1);

      leftCam.position.copy(headCam.position).addScaledVector(right, -ipd/2 + eyeOffsetX).addScaledVector(up, eyeOffsetY);
      rightCam.position.copy(headCam.position).addScaledVector(right, ipd/2 + eyeOffsetX).addScaledVector(up, eyeOffsetY);

      leftCam.quaternion.copy(headCam.quaternion);
      rightCam.quaternion.copy(headCam.quaternion);

      leftCam.rotation.y += convergence;
      rightCam.rotation.y -= convergence;

      leftCam.fov = fov;
      rightCam.fov = fov;
      leftCam.updateProjectionMatrix();
      rightCam.updateProjectionMatrix();
    }

    function update(dt) {
      if (!gameReady) { updateStereoCameras(); return; }
      updateStereoCameras();
    }

    let last = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      update(dt);
      renderer.setRenderTarget(rtLeft);
      renderer.render(scene, leftCam);
      renderer.setRenderTarget(rtRight);
      renderer.render(scene, rightCam);
      renderer.setRenderTarget(null);
      renderer.render(postScene, postCam);
    }
  })();
  </script>
</body>
</html>


