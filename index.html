<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Teste de Giroscópio — HTML</title>
  <style>
    :root { --bg:#0b0f14; --fg:#dce3ec; --muted:#8aa0b3; --accent:#7bdcff; }
    * { box-sizing: border-box; }
    body {
      margin: 0; height: 100dvh; background: radial-gradient(1200px 700px at 70% 20%, #101823 0%, #0b0f14 55%, #081018 100%);
      color: var(--fg); font: 500 16px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;
      display: grid; grid-template-rows: auto 1fr auto; gap: 8px;
    }
    header, footer { padding: 10px 14px; }
    header b { color: var(--accent); }
    .panel {
      display: grid; place-items: center; padding: 8px; gap: 12px;
    }
    .hud {
      display: grid; gap: 10px; width: min(720px, 92vw); background: #0f1621aa; border: 1px solid #1f2b3a; border-radius: 12px; padding: 12px;
      backdrop-filter: blur(3px);
    }
    .row { display: grid; gap: 8px; grid-template-columns: 1fr auto; align-items: center; }
    .controls { display: grid; gap: 8px; grid-template-columns: repeat(3, minmax(0,1fr)); }
    button, input[type="range"] {
      accent-color: var(--accent);
    }
    button {
      border: 1px solid #2a3b50; background: #142030; color: var(--fg); padding: 10px 12px; border-radius: 10px;
      cursor: pointer; transition: transform .05s ease;
    }
    button:active { transform: translateY(1px); }
    small { color: var(--muted); }
    .vals { font-feature-settings: "tnum" 1, "ss01" 1; font-variant-numeric: tabular-nums; color: #bcd0e0; }
    /* Cena 3D */
    .scene {
      width: min(440px, 86vw); height: min(440px, 86vw);
      perspective: 900px; display: grid; place-items: center; margin: 8px auto;
    }
    .cube {
      width: 220px; height: 220px; transform-style: preserve-3d; will-change: transform;
      transition: filter .2s ease;
    }
    .face {
      position: absolute; inset: 0; display: grid; place-items: center; font-weight: 700;
      background: linear-gradient(180deg, #152235, #0f1b2b);
      border: 1px solid #21405a; color: #d7f1ff; border-radius: 12px;
      box-shadow: inset 0 0 30px #00000066;
    }
    .face:nth-child(1){ transform: translateZ(110px); }
    .face:nth-child(2){ transform: rotateY(180deg) translateZ(110px); }
    .face:nth-child(3){ transform: rotateY(90deg) translateZ(110px); }
    .face:nth-child(4){ transform: rotateY(-90deg) translateZ(110px); }
    .face:nth-child(5){ transform: rotateX(90deg) translateZ(110px); }
    .face:nth-child(6){ transform: rotateX(-90deg) translateZ(110px); }
    .bad { filter: grayscale(.7) brightness(.85); }
    code { background:#0d1622; padding:2px 6px; border:1px solid #1b2b43; border-radius:6px; }
  </style>
</head>
<body>
  <header>
    <div><b>Teste de Giroscópio</b> — HTML puro com DeviceOrientation (fallback amplo)</div>
    <small>Dica: toque <b>Iniciar</b> (iOS exige gesto) e depois <b>Calibrar</b> na postura atual do aparelho.</small>
  </header>

  <section class="panel">
    <div class="scene">
      <div id="cube" class="cube">
        <div class="face">FRENTE</div>
        <div class="face">TRÁS</div>
        <div class="face">DIREITA</div>
        <div class="face">ESQUERDA</div>
        <div class="face">CIMA</div>
        <div class="face">BAIXO</div>
      </div>
    </div>

    <div class="hud">
      <div class="row">
        <div>
          <button id="btnStart">Iniciar</button>
          <button id="btnCalibrate">Calibrar neutro</button>
          <button id="btnReset">Reset</button>
        </div>
        <div class="vals" id="status">aguardando…</div>
      </div>

      <div class="controls">
        <label>Suavização
          <input id="rangeSmooth" type="range" min="0" max="0.4" step="0.01" value="0.18">
        </label>
        <label>Sensibilidade
          <input id="rangeSens" type="range" min="0.2" max="3" step="0.05" value="1">
        </label>
        <label>Zona morta (°)
          <input id="rangeDead" type="range" min="0" max="8" step="0.5" value="1.5">
        </label>
      </div>

      <div class="row">
        <div class="vals" id="readout">α 0.0 | β 0.0 | γ 0.0 • pitch 0.0 • roll 0.0</div>
        <small id="ori">orientação: ?</small>
      </div>

      <small>
        Notas rápidas: usa <code>DeviceOrientationEvent</code> (compatível amplo). Eixos são ajustados conforme
        <code>screen.orientation.angle</code>. “Calibrar” zera a postura atual como neutra.
      </small>
    </div>
  </section>

  <footer>
    <small>
      Funciona melhor em conexões seguras (https). Alguns iPhones exigem permissão explícita.
      Se a rotação parecer “invertida”, ajuste <b>Sensibilidade</b> para negativo digitando no campo (ex.: via DevTools) ou edite o código e inverta o sinal do eixo desejado.
    </small>
  </footer>

  <script>
    (() => {
      const cube = document.getElementById('cube');
      const statusEl = document.getElementById('status');
      const readout = document.getElementById('readout');
      const oriEl = document.getElementById('ori');
      const btnStart = document.getElementById('btnStart');
      const btnCal = document.getElementById('btnCalibrate');
      const btnReset = document.getElementById('btnReset');
      const rSmooth = document.getElementById('rangeSmooth');
      const rSens = document.getElementById('rangeSens');
      const rDead = document.getElementById('rangeDead');

      let started = false;
      let haveData = false;
      let smoothed = { pitch:0, roll:0 };
      let offsets = { pitch:0, roll:0 }; // neutro calibrado
      let lastAngles = { alpha:0, beta:0, gamma:0 }; // depuração
      let rafId = 0;

      const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
      const deadzone = (v, dz) => Math.abs(v) < dz ? 0 : v;

      function getScreenAngle() {
        const o = screen.orientation || screen.msOrientation;
        if (o && typeof o.angle === 'number') return o.angle;
        // iOS fallback (approx)
        return window.orientation || 0;
      }

      // Mapeia αβγ para pitch/roll levando em conta portrait/landscape
      function mapToPitchRoll(alpha, beta, gamma) {
        // beta: [-180,180] (inclinação frente/tras)
        // gamma: [-90,90]  (inclinação esq/dir)
        // alpha: [0,360)   (rumo/azimute)
        const ang = ((getScreenAngle() % 360) + 360) % 360;
        oriEl.textContent = `orientação: ${ang}°`;

        let pitch, roll;
        if (ang === 0) { // portrait
          pitch = beta;
          roll  = gamma;
        } else if (ang === 90) { // landscape-primary (botões à direita)
          // Segura melhor usando troca de eixos
          pitch = gamma;
          roll  = -beta;
        } else if (ang === 180) { // upside-down
          pitch = -beta;
          roll  = -gamma;
        } else if (ang === 270) { // landscape-secondary
          pitch = -gamma;
          roll  = beta;
        } else {
          pitch = beta; roll = gamma;
        }
        return { pitch, roll };
      }

      function onOrientation(e) {
        haveData = true;
        const alpha = typeof e.alpha === 'number' ? e.alpha : 0;
        const beta  = typeof e.beta  === 'number' ? e.beta  : 0;
        const gamma = typeof e.gamma === 'number' ? e.gamma : 0;
        lastAngles = { alpha, beta, gamma };
      }

      function applyTransform(pitchDeg, rollDeg) {
        // Rotação do cubo: X = pitch, Y = roll (ajustável)
        cube.style.transform = `rotateX(${pitchDeg}deg) rotateY(${rollDeg}deg)`;
      }

      function tick() {
        const { alpha, beta, gamma } = lastAngles;
        const mapped = mapToPitchRoll(alpha, beta, gamma);

        // Sensibilidade & zona morta
        const sens = parseFloat(rSens.value);
        const dz   = parseFloat(rDead.value);

        let pitch = (mapped.pitch - offsets.pitch) * sens;
        let roll  = (mapped.roll  - offsets.roll ) * sens;

        pitch = deadzone(pitch, dz);
        roll  = deadzone(roll , dz);

        // Suavização (low-pass)
        const a = parseFloat(rSmooth.value);
        smoothed.pitch += (pitch - smoothed.pitch) * a;
        smoothed.roll  += (roll  - smoothed.roll ) * a;

        // Aplica
        applyTransform(clamp(smoothed.pitch, -85, 85), clamp(smoothed.roll, -110, 110));

        // HUD
        readout.textContent =
          `α ${alpha.toFixed(1)} | β ${beta.toFixed(1)} | γ ${gamma.toFixed(1)} • `
          + `pitch ${smoothed.pitch.toFixed(1)} • roll ${smoothed.roll.toFixed(1)}`;

        rafId = requestAnimationFrame(tick);
      }

      async function requestIOSPermissionIfNeeded() {
        const DME = window.DeviceMotionEvent;
        const DOE = window.DeviceOrientationEvent;
        // iOS 13+ exige requestPermission em gesto do usuário
        try {
          if (DOE && typeof DOE.requestPermission === 'function') {
            const s = await DOE.requestPermission();
            return s === 'granted';
          }
          if (DME && typeof DME.requestPermission === 'function') {
            const s = await DME.requestPermission();
            return s === 'granted';
          }
        } catch (err) {
          console.warn('Permissão iOS negada/erro:', err);
          return false;
        }
        // Android/desktop geralmente não precisa
        return true;
      }

      function attachListeners() {
        window.addEventListener('deviceorientation', onOrientation, { passive: true });
        window.addEventListener('orientationchange', () => {
          // re-calcula offsets relativos ao novo eixo (opcional manter)
          // aqui apenas suavizamos uma transição visual
          cube.classList.add('bad');
          setTimeout(() => cube.classList.remove('bad'), 250);
        }, { passive: true });
      }

      async function start() {
        if (started) return;
        started = true;

        statusEl.textContent = 'solicitando permissão…';
        const ok = await requestIOSPermissionIfNeeded();
        if (!ok) {
          statusEl.textContent = 'permissão negada 😕 (iOS exige toque e permitir movimento).';
          started = false;
          return;
        }

        attachListeners();
        statusEl.textContent = 'coletando dados… mova o aparelho levemente.';
        cube.classList.remove('bad');

        // Espera primeiros frames para calibrar opcionalmente
        let tries = 0;
        const waitData = setInterval(() => {
          tries++;
          if (haveData || tries > 30) {
            clearInterval(waitData);
            statusEl.textContent = haveData ? 'ok! sensores ativos.' : 'sem dados (dispositivo sem suporte?)';
          }
        }, 100);

        cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(tick);
      }

      function calibrateNeutral() {
        // Define a postura atual como 0,0
        const mapped = mapToPitchRoll(lastAngles.alpha, lastAngles.beta, lastAngles.gamma);
        offsets.pitch = mapped.pitch;
        offsets.roll  = mapped.roll;
        statusEl.textContent = 'calibrado (neutro atualizado).';
      }

      function resetAll() {
        offsets = { pitch:0, roll:0 };
        smoothed = { pitch:0, roll:0 };
        statusEl.textContent = 'reset aplicado.';
      }

      btnStart.addEventListener('click', start);
      btnCal.addEventListener('click', calibrateNeutral);
      btnReset.addEventListener('click', resetAll);

      // Dica: se quiser auto-start quando possível (não iOS), descomente:
      // if (!/iphone|ipad|ipod/i.test(navigator.userAgent)) start();
    })();
  </script>
</body>
</html>
